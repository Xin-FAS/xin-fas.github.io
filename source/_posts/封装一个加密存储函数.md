---
title: 封装一个加密存储函数
date: 2023-09-09 22:48:43
tags: [JavaScript]
categories: [前端,前端其他]
---

## 介绍

功能以key-value形式存储数据，支持定义过期时间以及浏览器刷新（是否存储在`localStorage`）

## f-crypto.js（待开发）

```js
import CryptoJS from "crypto-js";

// 存储key和盐值
const keyMap = new Map()

/**
 * 加密
 * @param key
 * @param value
 * @param duration 过期时间（ms）
 * @returns {*}
 */
const encrypt = (key, value, duration) => {
    const salt = CryptoJS.lib.WordArray.random(128) + ''
    // 存储相关设置，设置过期时间
    keyMap.set(key, JSON.stringify({
        encryptSalt: salt,
        encryptDuration: duration === undefined ? -1 : performance.now() + duration
    }))
    // 加密
    return CryptoJS.AES.encrypt(JSON.stringify({ value }), salt).toString()
}


// 处理加密的数据
const handlerEncryptObj = ({ encryptSalt, encryptDuration }, timeout) => {
    const now = performance.now()
    // 过期
    if (encryptDuration !== -1 && encryptDuration < now)
        return (keyMap.delete(key), timeout(), void 0)
    // 解密
    const bytes = CryptoJS.AES.decrypt(encryptByte, encryptSalt)
    return JSON.parse(bytes.toString(CryptoJS.enc.Utf8)).value;
}

/**
 * 解密
 * @param key
 * @param encryptByte
 * @param timeout 过有效期回调
 * @returns {*}
 */
const decrypt = (key, encryptByte, timeout = () => {}) => {
    if (
        key === undefined ||
        encryptByte === undefined
    ) return
    if (keyMap.has(key)) {
        return handlerEncryptObj(JSON.parse(keyMap.get(key)), timeout)
    }
    if (localStorage.getItem(key))
        return handlerEncryptObj(JSON.parse(localStorage.getItem(key)), timeout)
}


const setLocalItem = (key, value, duration) => {

}


export {
    encrypt,
    decrypt
}
```
