---
title: 打字机效果指令（超级详细）
date: 2023-08-23 22:23:57
tags: [Vue, JavaScript]
categories: [前端]
---

## 基础使用

注册（vue2为例）

```js
import Vue from 'vue'
import write from "./f-write"

Vue.directive('write', write)
```

使用

```html
<script>
export default {
    data () {
        return {
            text: '我还是我'
        }
    },
}
</script>

<template>
    <div>
        <button @click="text='你还是你吗'">改变文字</button>
        <p v-write:200.2000.400="text" />
    </div>
</template>
```

解释：

每`200ms`打印一个字符，最开始等待`2400ms（2000ms + 400ms）`才开始打印

## f-write.js

### Vue2版本

```js
// 控制等待
let delayTime
// 控制文字打印
let times = []
// 清空所有定时器
const clearAllTimeout = () => {
    times = (times.forEach(clearTimeout), [])
    delayTime = (clearTimeout(delayTime), undefined)
}
// 让一个元素初始闪烁（模拟打字效果）
const initFlicker = (el, val = '_') => {
    let interval, timeout
    let text = []
    const setHitStatus = () => el.innerText = text.join('') + val
    const setTextStatus = () => el.innerText = text.join('')
    // 初始化
    el.innerText = ''
    // 开始
    const startFlicker = () => {
        const handler = () => {
            timeout = setTimeout(setTextStatus, 400)
            setHitStatus()
        }
        handler()
        interval = setInterval(handler, 1000)
    }
    // 结束，isEnd：是否强制结束
    const overFlicker = (isEnd = false) => {
        interval = (clearInterval(interval), undefined)
        if (!isEnd) return
        timeout = (clearTimeout(timeout), undefined)
        setTextStatus()
    }
    // 操作文字，支持回调形式，用于操作全部文字
    const addFlickerText = val => {
        const typeofVal = typeof val
        if (typeofVal === 'function') text = val(text)
        if (typeofVal === 'string' || typeofVal === 'number' ) text.push(val)
        setHitStatus()
    }
    return {
        startFlicker,
        overFlicker,
        addFlickerText
    }
}
// 首次等待
const toSleep = delay => new Promise(res => delayTime = setTimeout(res, delay))
// 记录下用于销毁
let overFlickerR
const FWrite =  {
    async bind (el, binding) {
        const { arg, modifiers, value } = binding
        // 累加等待值
        const delay = Object.entries(modifiers).map(v => +v[0]).reduce((count, num) => count + num, 0)
        const duration = (arg === undefined) ? 150: +arg
        // 先清空
        clearAllTimeout()
        // 初始闪烁效果
        const { addFlickerText, overFlicker, startFlicker } = initFlicker(el)
        overFlickerR = overFlicker
        startFlicker()
        // 开始等待
        await toSleep(delay)
        // 多个定时器延迟赋值
        const innerTextArr = value.trim().split('')
        const lastIndex = innerTextArr.length - 1
        for (const [index, char] of innerTextArr.entries()) {
            times.push(setTimeout(() => {
                addFlickerText(char)
                // 最后关闭打字效果
                if (index === lastIndex) overFlicker()
            }, +index * duration))
        }
    },
    update (el, binding) {
        // 结束
        FWrite.unbind()
        const { value, oldValue } = binding
        // 防止其他地方的刷新
        if (value === oldValue) return
        // 重新开始
        FWrite.bind(el, binding)
    },
    unbind () {
        overFlickerR(true)
        clearAllTimeout()
    }
}

export default FWrite
```
## 指令介绍
设计思路：

1. 使用`interval` + `timeout`完成光标闪烁
2. 绑定值更新后根据值是否更新判断是否重新开始
3. 离开后结束（强制）

对于强制结束和结束的区别，就是在结束后光标会不会立马消失上

指令其中的`addFlickerText`方法，预留了回调形式改变文字，后续可以自定义更多效果（如模拟打错了删几个再打）

其他详细控制见代码中的注释
